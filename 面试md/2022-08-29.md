## 垃圾回收和内存泄漏
   # https://juejin.cn/post/6844904036932534279?share_token=d5283596-2bd5-4fcf-99e5-37f14c8b9ade
   # https://juejin.cn/post/6844903781079973902?share_token=01e2a04d-4c5e-4d07-a5c2-b96a4db37ca0
   # https://juejin.cn/post/6981588276356317214#heading-13
   # 不用的内存没有及时得到释放，就会造成内存泄漏
   # 造成内存泄漏的情况：未定义的变量会绑定到window上，定时器未清除，闭包里面的变量
   # 垃圾回收  -->标记清除和引用计数
   # 标记清除：
   # -->  垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0
   # -->  然后从各个根对象开始遍历，如果可以从根对象访问到该对象（是否有外部传入的引用），就把该对象改成1
   # -->  清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间
   # -->  最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收
   # 引用计数：
   # -->  当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1
   # -->  如果同一个值又被赋给另一个变量，那么引用数加 1
   # -->  如果该变量的值被其他的值覆盖了，则引用次数减 1
   # -->  当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存


## 浏览器输入url是如何解析的
   # ---> 查询缓存 首先需要找到这个 url 域名的服务器 ip,为了寻找这个 ip，浏览器首先会寻找缓存，查看缓存中是否有记录
   # ---> DNS解析。获取ip地址
   # ---> TCP 连接：TCP 三次握手
   # ---> 发送 HTTP 请求
   # ---> 服务器处理收到的请求，将数据返回至浏览器
   # ---> 浏览器收到HTTP响应,读取页面内容，浏览器渲染，解析html
   # ---> 生成Dom树、解析css样式、js交互
   
## 浏览器缓存  https://juejin.cn/post/6992843117963509791#heading-3
   # ---> 强缓存 控制强制缓存的字段分别是 Expires 和 Cache-Control，其中Cache-Control优先级比Expires高
   # expires：过期时间，
   # Cache-Control：
   # ---> public：所有内容都将被缓存（客户端和代理服务器都可缓存）
   # ---> private：所有内容只有客户端可以缓存，Cache-Control的默认取值
   # ---> no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定
   # ---> no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
   # ---> max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效

   # ---> 协商缓存 控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。
   # ---> Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间
   # ---> If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件处。
   # ---> Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)
   # ---> If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200

## http和https 未明白
   # ---> http和https的区别
   # ---> HTTP是明文传输，不安全的，HTTPS是加密传输，安全的多
   # ---> HTTP标准端口是80，HTTPS标准端口是443
   # ---> HTTP不用认证证书免费，HTTPS需要认证证书要钱
   # ---> HTTP是无状态的，HTTPS是有状态的
   # HTTP 1.0(1996年)
   # ---> 任意数据类型都可以发送
   # ---> 有GET、POST、HEAD三种方法
   # ---> 无法复用TCP连接(长连接)
   # ---> 有丰富的请求响应头信息。以header中的Last-Modified/If-Modified-Since和Expires作为缓存标识
   # HTTP 1.1(1997年)
   # ---> 引入更多的请求方法类型PUT、PATCH、DELETE、OPTIONS、TRACE、CONNECT
   # ---> 引入长连接，就是TCP连接默认不关闭，可以被多个请求复用，通过请求头connection:keep-alive设置
   # ---> 引入管道连接机制，可以在同一TCP连接里，同时发送多个请求
   # ---> 强化了缓存管理和控制Cache-Control、ETag/If-None-Match
   # 缺点：主要是连接缓慢，服务器只能按顺序响应，如果某个请求花了很长时间，就会出现请求队头阻塞
   # HTTP 2.0(2015年)
   # ---> 使用新的二进制协议，不再是纯文本，避免文本歧义，缩小了请求体积
   # ---> 多路复用，同域名下所有通信都是在单链接(双向数据流)完成，提高连接的复用率，在拥塞控制方面有更好的能力提升
   # ---> 增加了安全性，使用HTTP 2.0
   # ---> 允许服务端主动推送数据给客户端
   # 缺点：主要是连接缓慢，服务器只能按顺序响应，如果某个请求花了很长时间，就会出现请求队头阻塞